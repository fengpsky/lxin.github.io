
<!DOCTYPE html>
<html lang="en">
  <head>

    <meta charset="utf-8">
    <title>vxlan的内核实现</title>
    
    <meta name="author" content="Xin Long">

    <!-- Le HTML5 shim, for IE6-8 support of HTML elements -->
    <!--[if lt IE 9]>
      <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <!-- Le styles -->
    <link href="/assets/themes/twitter/bootstrap/css/bootstrap.min.css" rel="stylesheet">
    <link href="/assets/css/style.css?body=1" rel="stylesheet" type="text/css" media="all">
    <link href="/assets/css/syntax.css" rel="stylesheet" type="text/css" media="all">
    <link href="/assets/css/style_logo.css" rel="stylesheet" type="text/css" media="all">

    <link rel="alternate" type="application/atom+xml" href="atom.xml" title="Atom feed">
    <script type="text/javascript" src="/assets/js/jquery.js"></script>
    <script type="text/javascript" src="/assets/js/bootstrap.min.js"></script>
    <script type="text/javascript" src="/assets/js/jquery.flexslider.js"></script>
    
    <!-- Le fav and touch icons -->
    <link rel="shortcut icon" href="/assets/images/linux.ico">
    <!-- Update these with your own images
    <link rel="apple-touch-icon" href="images/apple-touch-icon.png">
    <link rel="apple-touch-icon" sizes="72x72" href="images/apple-touch-icon-72x72.png">
    <link rel="apple-touch-icon" sizes="114x114" href="images/apple-touch-icon-114x114.png">
  -->
    
  </head>

  <body style="background: #333 url(/assets/images/bg.jpg) repeat top left;">
    <!--
    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
    @@@;;;;;;;;@@@@@@@@@@@;;;;;;;;@@@@@@@@@@@;;;;;;;;@@@@@@@@@@@@@;;;;;;;;@@@@
    @@@@@;;;;@@@@@@@@@@@@@@@;;;;@@@@@@@@@@@@@@@;;;;@@@@@@@@@@@@@@@@@;;;;@@@@@@
    @@@@@;;;;@@@@@@@@@@@@@@@;;;;@@@@@@@@@@@@@@@;;;;@@@@@@@@@@@@@@@@@;;;;@@@@@@
    @@@@@;;;;@@@@@@@@@@@@@@@;;;;@@@@@@@@@@@@@@@;;;;@@@@@@@@@@@@@@@@@;;;;@@@@@@
    @@@@@;;;;@@@@@@@@@@@@@@@;;;;@@@@@@@@@@@@@@@;;;;@@@@@@@@@@@@@@@@@;;;;@@@@@@
    @@@@@;;;;@@@@@@@@@@@@@@@;;;;@@@@@@@@@@@@@@@;;;;@@@@@@@@@@@@@@@@@;;;;@@@@@@
    @@@@@;;;;@@@@@@@@@@@@@@@;;;;@@@@@@@@@@@@@@@;;;;@@@@@@@@@@@@@@@@@;;;;@@@@@@
    @@@@@;;;;@@@@@@@@@@@@@@@;;;;@@@@@@@@@@@@@@@;;;;@@@@@@@@@@@@@@@@@;;;;@@@@@@
    @@@@@;;;;@@@@@@@@@@@@@@@;;;;@@@@@@@@@@@@@@@;;;;@@@@@@@@@@@@@@@@@;;;;@@@@@@
    @@@@@;;;;@@@@@@@@@@@@@@@;;;;@@@@@@@@@@@@@@@;;;;@@@@@@@@@@@@@@@@@;;;;@@@@@@
    @@@@@;;;;;;;;;;;;;;;;;;;;;;;@@@@@@@@@@@@@@@;;;;@@@@@@@@@@@@@@@@@;;;;@@@@@@
    @@@@@;;;;;;;;;;;;;;;;;;;;;;;@@@@@@@@@@@@@@@;;;;@@@@@@@@@@@@@@@@@;;;;@@@@@@
    @@@@@;;;;;;;;;;;;;;;;;;;;;;;@@@@@@@@@@@@@@@;;;;@@@@@@@@@@@@@@@@@;;;;@@@@@@
    @@@@@;;;;@@@@@@@@@@@@@@@;;;;@@@@@@@@@@@@@@@;;;;@@@@@@@@@@@@@@@@@;;;;@@@@@@
    @@@@@;;;;@@@@@@@@@@@@@@@;;;;@@@@@@@@@@@@@@@;;;;@@@@@@@@@@@@@@@@@;;;;@@@@@@
    @@@@@;;;;@@@@@@@@@@@@@@@;;;;@@@@@@@@@@@@@@@;;;;@@@@@@@@@@@@@@@@@;;;;@@@@@@
    @@@@@;;;;@@@@@@@@@@@@@@@;;;;@@@@@@@@@@@@@@@;;;;@@@@@@@@@@@@@@@@@;;;;@@@@@@
    @@@@@;;;;@@@@@@@@@@@@@@@;;;;@@@@@@@@@@@@@@@;;;;@@@@@@@@@@@@@@@@@;;;;@@@@@@
    @@@@@;;;;@@@@@@@@@@@@@@@;;;;@@@@@@@@@@@@@@@;;;;@@@@@@@@@@@@@@@@@;;;;@@@@@@
    @@@@@;;;;@@@@@@@@@@@@@@@;;;;@@@@@@@@@@@@@@@;;;;@@@@@@@@@@@@@@@@@;;;;@@@@@@
    @@@@@;;;;@@@@@@@@@@@@@@@;;;;@@@@@@@@@@@@@@@;;;;@@@@@@@@@@@@@@@@@;;;;@@@@@@
    @@@@@;;;;@@@@@@@@@@@@@@@;;;;@@@@@@@@@@@@@@;;;;@@@@@@@@@@@@@@@@@;;;;@@@@@@@
    @@@@@;;;;@@@@@@@@@@@@@@@;;;;@@@@@@@@@@@@@;;;;@@@@@@@@@@@@@@@@@;;;;@@@@@@@@
    @@@@@;;;;@@@@@@@@@@@@@@@;;;;@@@@@@@@@@@;;;;;@@@@@@@@@@@@@@@@;;;;;@@@@@@@@@
    @@@;;;;;;;;@@@@@@@@@@@;;;;;;;;@@@@;;;;;;;@@@@@@@@@@@@@@;;;;;;;@@@@@@@@@@@@
    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
    -->
    <!--[if lt IE 8]>
	<div style='border:1px solid #F7941D;background:#FEEFDA;text-align:center;clear:both;height:75px;position:relative;'>
		<div style='position:absolute;right:3px;top:3px;font-family:courier new;font-weight:bold;'>
			<a href='#' onclick='javascript:this.parentNode.parentNode.style.display="none";return false;'>
				<img src='http://www.ie6nomore.com/files/theme/ie6nomore-cornerx.jpg' style='border:none;' alt='Close this notice'/>
			</a>
		</div>
		<div style='width:640px;margin:0 auto;text-align:left;padding:0;overflow:hidden;color:black;'>
			<div style='width:75px;float:left;'>
				<img src='http://www.ie6nomore.com/files/theme/ie6nomore-warning.jpg' alt='Warning!'/>
			</div>
			<div style='width:275px;float:left;font-family:Arial,sans-serif;'>
				<div style='font-size:14px;font-weight:bold;margin-top:12px;'>You are using an outdated browser</div>
				<div style='font-size:12px;margin-top:6px;line-height:12px;'>
					For a better experience using this site, please upgrade to a modern web browser.
				</div>
			</div>
			<div style='width:75px;float:left;'>
				<a href='http://www.firefox.com' target='_blank'>
					<img src='http://www.ie6nomore.com/files/theme/ie6nomore-firefox.jpg' style='border:none;' alt='Get Firefox 3.5'/>
				</a>
			</div>
			<div style='width:75px;float:left;'>
				<a href='http://www.browserforthebetter.com/download.html' target='_blank'>
					<img src='http://www.ie6nomore.com/files/theme/ie6nomore-ie8.jpg' style='border:none;' alt='Get IE 8'/>
				</a>
			</div>
			<div style='width:73px;float:left;'>
				<a href='http://www.apple.com/safari/download/' target='_blank'>
					<img src='http://www.ie6nomore.com/files/theme/ie6nomore-safari.jpg' style='border:none;' alt='Get Safari 4'/>
				</a>
			</div>
			<div style='float:left;'>
				<a href='http://www.google.com/chrome' target='_blank'>
					<img src='http://www.ie6nomore.com/files/theme/ie6nomore-chrome.jpg' style='border:none;' alt='Get Google Chrome'/>
				</a>
			</div>
		</div>
	</div>
<![endif]-->


    <div class="navbar" id="top-navbar">
      <div class="navbar-inner" style="">
        <div class="container">
          <a class="brand" href="/">Xin Long</a>
          <ul class="nav">
            
            
            


  
    
  
    
    	
    	<li><a href="/pages/pages.html">页面</a></li>
    	
    
  
    
    	
    	<li><a href="/pages/message.html">留言</a></li>
    	
    
  
    
    	
    	<li><a href="/pages/about.html">关于</a></li>
    	
    
  
    
    	
    	<li><a href="/pages/tags.html">标签</a></li>
    	
    
  
    
    	
    	<li><a href="/pages/picture.html">相册</a></li>
    	
    
  
    
  
    
  
    
    	
    	<li><a href="/pages/categories.html">分类</a></li>
    	
    
  
    
  
    
    	
    	<li><a href="/pages/tools.html">Wiki</a></li>
    	
    
  
    
  
    
  
    
  
    
    	
    	<li><a href="/pages/archive.html">归档</a></li>
    	
    
  
    
  
    
  



          </ul>
          <ul class="nav subscription pull-right" data-subscription="rss">
            <li>
              <a href="/atom.xml" rel="nofollow" title="subscribe via RSS">RSS</a>
            </li>
          </ul>
          <form class="navbar-search pull-right" method="get" action="http://www.google.com/search" target="google_window">
            <label for="g_search" class="hidden"></label>
            <input id="g_search" type="text" class="search-query" placeholder="Search..." name="q" />
            <input type="submit" name=”btnG” style="display:none" id="searchsubmit" value="Search" />
            <input type="hidden" name="ie" value="UTF-8" />
            <input type="hidden" name="oe" value="UTF-8" />
            <input type="hidden" name="hl" value="zh-CN" />
            <input type="hidden" name="domains" value="http://lxin.org" />
            <input type="hidden" name="sitesearch" value="http://lxin.org" />
          </form>
        </div>
      </div>
    </div>

    <div class="container">

      <div id="main-content" class="content">
        
<div class="page-header">
    <h1>vxlan的内核实现 <small><!--Supporting tagline--></small></h1>
</div>

<div class="row">
  <div id="article_indent" class="span9 pull-left">
    <div class="span3 article_published">发表于
      <span class="date">05 April 2014</span>
      <div class="article_gplus"><div class="g-plusone" data-size="small" data-annotation="none"></div></div>
    </div>
    <div class="clear"></div>
    
      
<h3 id="section">几个关键的结构体</h3>

<h4 id="vxlannet">vxlan_net</h4>

<pre><code>struct vxlan_net {
        struct list_head  vxlan_list;
        struct hlist_head sock_list[PORT_HASH_SIZE];
        spinlock_t        sock_lock;
};
</code></pre>

<p>一个每名字空间的数据块。</p>

<h4 id="struct-vxlansock">struct vxlan_sock</h4>

<pre><code>struct vxlan_sock {
        struct hlist_node hlist;
        vxlan_rcv_t      *rcv;//接收函数，但事实上入口接收是encap_rcv()
        void             *data;
        struct work_struct del_work;
        struct socket    *sock;
        struct rcu_head   rcu;
        struct hlist_head vni_list[VNI_HASH_SIZE];//关联vni
        atomic_t          refcnt;
        struct udp_offload udp_offloads;//vxlan udp offloads使用
};
</code></pre>

<h4 id="struct-vxlandev">struct vxlan_dev</h4>

<pre><code>struct vxlan_dev {
        struct hlist_node hlist;        /* vni hash table */
        struct list_head  next;         /* vxlan's per namespace list */
        struct vxlan_sock *vn_sock;     /* listening socket */
        struct net_device *dev;
        struct vxlan_rdst default_dst;  /* default destination */
        union vxlan_addr  saddr;        /* source address */
        __be16            dst_port;
        __u16             port_min;     /* source port range */
        __u16             port_max;
        __u8              tos;          /* TOS override */
        __u8              ttl;
        u32               flags;        /* VXLAN_F_* below */

        struct work_struct sock_work;
        struct work_struct igmp_join;
        struct work_struct igmp_leave;//三个工作队列

        unsigned long     age_interval;
        struct timer_list age_timer;
        spinlock_t        hash_lock;
        unsigned int      addrcnt;
        unsigned int      addrmax;

        struct hlist_head fdb_head[FDB_HASH_SIZE];//转发表
};
</code></pre>

<p>net_device的private成员，即vxlan设备的私有信息</p>

<h4 id="struct-vxlanrdst">struct vxlan_rdst</h4>

<pre><code>struct vxlan_rdst {
        union vxlan_addr         remote_ip;
        __be16                   remote_port;
        u32                      remote_vni;
        u32                      remote_ifindex;
        struct list_head         list;
        struct rcu_head          rcu;
};
</code></pre>

<p>存在在vxlan_fdb的remotes中用于描述远端的地址信息.</p>

<h4 id="struct-vxlanfdb">struct vxlan_fdb</h4>

<pre><code>/* Forwarding table entry */
struct vxlan_fdb {
        struct hlist_node hlist;        /* linked list of entries */
        struct rcu_head   rcu;
        unsigned long     updated;      /* jiffies */
        unsigned long     used;
        struct list_head  remotes;//struct vxlan_rdst链表
        u16               state;        /* see ndm_state */
        u8                flags;        /* see ndm_flags */
        u8                eth_addr[ETH_ALEN];//
};
</code></pre>

<p>转发表，存在在vxlan_dev的fdb_head中</p>

<h3 id="section-1">初始化</h3>

<h4 id="section-2">注册模块</h4>

<h5 id="vxlaninitmoduledriversnetvxlanc-">vxlan_init_module(),drivers/net/vxlan.c, 也是比较清晰的几行代码.</h5>

<ol>
  <li>
    <p>vxlan_wq = alloc_workqueue(“vxlan”, 0, 0);申请一个工作队列，后面会说到它的作用. vxlan_wq是global的</p>
  </li>
  <li>
    <p>rc = register_pernet_subsys(&amp;vxlan_net_ops);注册一个每名字空间的操作</p>

    <pre><code> static struct pernet_operations vxlan_net_ops = {
         .init = vxlan_init_net,
         .id   = &amp;vxlan_net_id,
         .size = sizeof(struct vxlan_net),
 };
</code></pre>
  </li>
  <li>
    <p>rc = register_netdevice_notifier(&amp;vxlan_notifier_block); 网络通知链</p>
  </li>
  <li>
    <p>rc = rtnl_link_register(&amp;vxlan_link_ops);rtnl框架注册link操作,见rtnl框架分析</p>
  </li>
  <li>
    <p>其中，在vxlan_init_net()中，获取一块空间，　用来存放一个pernet的vxlan_net,　并进行初始化。</p>
  </li>
</ol>

<h4 id="section-3">创建</h4>

<h5 id="vxlannewlink">vxlan_newlink()中完成</h5>

<ol>
  <li>这是一个rtnl框架注册过的函数，　因此rtnl执行到这的时候net_device己经创建，并且己调用相应的setup()函数设置过,见rtnl_netlink分析.</li>
</ol>

<p>vxlan_setup()中，为net_device设置了ops, 以及初始化fdb, 还有三个工作队列</p>

<pre><code>    static const struct net_device_ops vxlan_netdev_ops = {
            .ndo_init               = vxlan_init,
            .ndo_uninit             = vxlan_uninit,
            .ndo_open               = vxlan_open,
            .ndo_stop               = vxlan_stop,
            .ndo_start_xmit         = vxlan_xmit,
            .ndo_get_stats64        = ip_tunnel_get_stats64,
            .ndo_set_rx_mode        = vxlan_set_multicast_list,
            .ndo_change_mtu         = vxlan_change_mtu,
            .ndo_validate_addr      = eth_validate_addr,
            .ndo_set_mac_address    = eth_mac_addr,
            .ndo_fdb_add            = vxlan_fdb_add,
            .ndo_fdb_del            = vxlan_fdb_delete,
            .ndo_fdb_dump           = vxlan_fdb_dump,
    };

    INIT_WORK(&amp;vxlan-&gt;igmp_join, vxlan_igmp_join);
    INIT_WORK(&amp;vxlan-&gt;igmp_leave, vxlan_igmp_leave);
    INIT_WORK(&amp;vxlan-&gt;sock_work, vxlan_sock_work);

最后面的这个工作队列会在netlink的时候触发(ndo_init).在它里面会创建传说中的vxlan_sock
</code></pre>

<ol>
  <li>
    <p>接着将其private还原成struct vxlan_dev,进行初始化, 如：</p>

    <pre><code> struct vxlan_rdst *dst = &amp;vxlan-&gt;default_dst;
 dst-&gt;remote_vni = vni;
 dst-&gt;remote_ip.sin.sin_addr.s_addr = nla_get_be32(data[IFLA_VXLAN_GROUP]);
 dst-&gt;remote_ip.sa.sa_family = AF_INET;
 vxlan-&gt;saddr.sin.sin_addr.s_addr = nla_get_be32(data[IFLA_VXLAN_LOCAL]);
 vxlan-&gt;saddr.sa.sa_family = AF_INET;
 dst-&gt;remote_ifindex = nla_get_u32(data[IFLA_VXLAN_LINK]
 ....
 vxlan-&gt;dst_port = nla_get_be16(data[IFLA_VXLAN_PORT]);
</code></pre>
  </li>
  <li>并且会通过vxlan_find_vni(net, vni, vxlan-&gt;dst_port)对vni进行duplicate检测</li>
  <li>
    <p>调用vxlan_fdb_create()创建条转发项</p>

    <pre><code> err = vxlan_fdb_create(vxlan, all_zeros_mac,
                        &amp;vxlan-&gt;default_dst.remote_ip,
                        NUD_REACHABLE|NUD_PERMANENT,
                        NLM_F_EXCL|NLM_F_CREATE,
                        vxlan-&gt;dst_port,
                        vxlan-&gt;default_dst.remote_vni,
                        vxlan-&gt;default_dst.remote_ifindex,
                        NTF_SELF);
</code></pre>
  </li>
</ol>

<p>5.注册net_device,同时在register_netdevice时利用ndo_init  queue_work(vxlan_wq, &amp;vxlan-&gt;sock_work);触发vxlan_sock_work(). 此时就能用ifconfig 看到设备了,并再添加进行vxlan_net中。</p>

<h4 id="vxlansocket">创建vxlan_socket</h4>

<h5 id="vxlansockwork">在vxlan_sock_work()中完成</h5>

<ol>
  <li>
    <p>vxlan_sock_add(),调用vxlan_socket_create(),如果失败，就用vxlan_find_sock()在pernet中去根据port去找</p>
  </li>
  <li>
    <p>在,vxlan_socket_create中,先申请一个vs. 再创建一个sock</p>

    <pre><code> if (ipv6)
         sock = create_v6_sock(net, port);
 else
         sock = create_v4_sock(net, port);
</code></pre>

    <p>相信你会看个这个很水的sock,连创建函数都是定制的, create_v4_sock:</p>

    <pre><code> struct sockaddr_in vxlan_addr = {
         .sin_family = AF_INET,
         .sin_addr.s_addr = htonl(INADDR_ANY),
         .sin_port = port,
 };
 rc = sock_create_kern(AF_INET, SOCK_DGRAM, IPPROTO_UDP, &amp;sock);
 ....
 rc = kernel_bind(sock, (struct sockaddr *) &amp;vxlan_addr,
                  sizeof(vxlan_addr));
</code></pre>

    <p>上面才回到通用创建的接口上。</p>
  </li>
  <li>
    <p>还有一个重要的操作，就是vs-&gt;rcv = rcv，设置接收函数.当然先调用函数调用在下面设置：</p>

    <pre><code> udp_sk(sk)-&gt;encap_type = 1;
 udp_sk(sk)-&gt;encap_rcv = vxlan_udp_encap_recv;
</code></pre>

    <p>对于这个函数，会在接收时重点说。</p>
  </li>
</ol>

<h3 id="section-4">打开</h3>

<h5 id="ifconfig-vxlan-up-vxlanopen">既然是虚拟网络设置，就按个这个框架来说明，ifconfig vxlan* up, 调用vxlan_open()，做了两件事情</h5>

<ol>
  <li>
    <p>queue_work(vxlan_wq, &amp;vxlan-&gt;igmp_join);唤醒另一个工作队列</p>
  </li>
  <li>
    <p>还有一个定时器，后面再做深入</p>
  </li>
  <li>
    <p>vxlan_igmp_join()中，主要还是调用通用接口来设置vxlan_sock加入mgroup.</p>

    <pre><code> struct sock *sk = vs-&gt;sock-&gt;sk;
 int ifindex = vxlan-&gt;default_dst.remote_ifindex;
 struct ip_mreqn mreq = {
                     .imr_multiaddr.s_addr   = ip-&gt;sin.sin_addr.s_addr,
                     .imr_ifindex            = ifindex,
             };

             ip_mc_join_group(sk, &amp;mreq);
</code></pre>
  </li>
</ol>

<p>很显然，从一开始到现在都是让这个sock能有接收包的能力，似乎在发包时没有让你承载travel ip栈的想法</p>

<h3 id="section-5">发送</h3>

<h5 id="ndostartxmitvxlanxmit-ether">ndo_start_xmit函数是vxlan_xmit, 自然由它完成发送,此时的发是一个完整的ether包。</h5>

<ol>
  <li>
    <p>f = vxlan_find_mac(vxlan, eth-&gt;h_dest); 先去fdb表中找vxlan_fdb转发项,相当于协议栈中的dst_entry, 当然是通过mac地址来找的</p>
  </li>
  <li>
    <p>如果没有找着，一开始还没学习通常都会这样，就会执行f = vxlan_find_mac(vxlan, all_zeros_mac); all_zeros_mac对应的那个项就是我们一开始添加的那个，所以应该会有期望结果返回，而返回的结中的目的地址就是添加时的参数里的那个多播地址，　就用在这里了。</p>
  </li>
  <li>
    <p>当然找着的转发项可能存在多个目的地址，因此：</p>

    <pre><code> list_for_each_entry_rcu(rdst, &amp;f-&gt;remotes, list) {
         struct sk_buff *skb1;

         if (!fdst) {
                 fdst = rdst;
                 continue;
         }
         skb1 = skb_clone(skb, GFP_ATOMIC);
         if (skb1)
                 vxlan_xmit_one(skb1, dev, rdst, did_rsc);
 }

 if (fdst)
         vxlan_xmit_one(skb, dev, fdst, did_rsc);
</code></pre>
  </li>
  <li>
    <p>可见在vxlan_xmit 中完成了转发项的查找，再调用vxlan_xmit_one, 关键性的几行代码:</p>

    <pre><code> fl4.flowi4_oif = rdst-&gt;remote_ifindex;
 fl4.flowi4_tos = RT_TOS(tos);
 fl4.daddr = dst-&gt;sin.sin_addr.s_addr;
 fl4.saddr = vxlan-&gt;saddr.sin.sin_addr.s_addr;

 rt = ip_route_output_key(dev_net(dev), &amp;fl4);
</code></pre>

    <p>这便是构建flowi,完成路由的查找，　再往后的发送就是vxlan_xmit_skb了。</p>
  </li>
  <li>
    <p>在这个函数中,非常重要的一步:</p>

    <pre><code> min_headroom = LL_RESERVED_SPACE(rt-&gt;dst.dev) + rt-&gt;dst.header_len
                 + VXLAN_HLEN + sizeof(struct iphdr)
                 + (vlan_tx_tag_present(skb) ? VLAN_HLEN : 0);

 /* Need space for new headers (invalidates iph ptr) */
 err = skb_cow_head(skb, min_headroom);
</code></pre>

    <p>skb_cow_head是用来拷贝和扩展头部空间的,这个函数有点麻烦，就不分析了.</p>

    <pre><code> vxh = (struct vxlanhdr *) __skb_push(skb, sizeof(vxh));
 vxh-&gt;vx_flags = htonl(VXLAN_FLAGS);
 vxh-&gt;vx_vni = vni;

 __skb_push(skb, sizeof(uh));
 skb_reset_transport_header(skb);
 uh = udp_hdr(skb);

 uh-&gt;dest = dst_port;
 uh-&gt;source = src_port;

 uh-&gt;len = htons(skb-&gt;len);
 uh-&gt;check = 0;

 err = handle_offloads(skb);
 if (err)
         return err;

 skb_set_owner_w(skb, vs-&gt;sock-&gt;sk);
</code></pre>

    <p>这些代码不用说了，　就是扩展完之后，进行vxlan头部，　和udp头部的填充的,</p>
  </li>
  <li>
    <p>再接iptunnel_xmit函数完成发送，　这个函数是ip_tunnel添加ip头部并发送的必调函数。见ip_tunnel框架的分析.</p>

    <p>另外在vxlan整个代码处理过程中，虽说它是个tunnel，　但并没有套用用ip_tunnel这个框架，不明白为什么加载时还要依赖ip_tunnel这个模块</p>
  </li>
</ol>

<h3 id="section-6">接收</h3>

<h5 id="vsudpsockencaprcv--vxlanudpencaprecvudprcv">上面提到了vs对应的udp_sock中的encap_rcv = vxlan_udp_encap_recv，　则在接收于会交给这个接口，　默认你是了解udp_rcv的。</h5>

<ol>
  <li>
    <p>此时到的数据是一个ether包+vxlan头部,因此首先获取vxh头，然后再利用ip_tunnel的另一个接口移动头部指针到正确位置:</p>

    <pre><code> vxh = (struct vxlanhdr *)(udp_hdr(skb) + 1);
 ...
 if (iptunnel_pull_header(skb, VXLAN_HLEN, htons(ETH_P_TEB)))
     goto drop;
</code></pre>
  </li>
  <li>
    <p>接下来就调用到了vxlan_rcv:</p>

    <pre><code> vxlan = vxlan_vs_find_vni(vs, vni);
 if (!vxlan)
         goto drop;
</code></pre>

    <p>先判断vni是否存在，不存在就drop.</p>

    <pre><code> if ((vxlan-&gt;flags &amp; VXLAN_F_LEARN) &amp;&amp;
     vxlan_snoop(skb-&gt;dev, &amp;saddr, eth_hdr(skb)-&gt;h_source))
         goto drop;
</code></pre>

    <p>vxlan_snoop重要的一步，是fdb项的学习,它会把此次通信的包以mac为索引添加进fdb表.当然对于这种表，有添加就得有清理，类似于邻居表或路由表，还记得初始化那会一个定时器吗，没有讲，它的作用就是来根据时间做表的清理工作的。</p>
  </li>
  <li>
    <p>到此，就剩下把这个完整的ether包上交了, netif_rx(),好经典好古老的一个接口，相信你还记得它。</p>
  </li>
</ol>


    
    <hr>
    <div class="pagination">
      <ul>
      
        <li class="prev"><a href="/linux%20kernel/2014/04/04/rtnetlink-architecture" title="rtnetlink框架">&larr; Previous</a></li>
      
        <li><a href="/pages/archive.html">Archive</a></li>
      
        <li class="next"><a href="/linux%20kernel/2014/04/07/linux-vxlan-configure" title="linux vxlan的使用">Next &rarr;</a></li>
      
      </ul>
    </div>
    <hr>
    


  <div id="disqus_thread"></div>
<script type="text/javascript">
    var disqus_developer = 1;
    var disqus_shortname = 'lxin'; // required: replace example with your forum shortname
    
    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">blog comments powered by <span class="logo-disqus">Disqus</span></a>



  </div>

  <div class="span3 pull-right">
    <ul class="nav nav-list">
      <li class="nav-header">分类</li>
      
       
        
        <li>
        
        <a href="/pages/categories.html#linux tool-ref">linux tool <span>3</span></a>
        </li>
       
        
        <li class="active">
        
        <a href="/pages/categories.html#linux kernel-ref">linux kernel <span>5</span></a>
        </li>
      
      
        <li class="nav-header">Tags</li>
        
        


  
     
    	<li><a href="/pages/tags.html#kernel-ref">kernel <span>5</span></a></li>
    
  



      
    </ul>
  </div>
</div>

<!-- Gplus -->
<script type="text/javascript">
  window.___gcfg = {lang: 'zh-CN'};

  (function() {
    var po = document.createElement('script'); po.type = 'text/javascript'; po.async = true;
    po.src = 'https://apis.google.com/js/plusone.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(po, s);
  })();
</script>



      </div>

      <footer>
        <p>&copy; Xin Long 2014 
          with help from Jijing Huang
        </p>
      </footer>

    </div> <!-- /container -->

    
    <script type="text/javascript" src="/assets/js/sd.js"></script>
  </body>
</html>

